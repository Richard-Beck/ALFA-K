---
title: "README"
author: "Richard J Beck"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---

Validating ALFA-K against output of ABM simulations  

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "~/projects/008_birthrateLandscape/ALFA-K/")
```

Shapiro test confirms the current procedure generates normally distributed fitness, meeting definition of GRF. 
```{r}

grf <- function(nwaves,rnge,dim){
  matrix(runif(dim*nwaves,min = rnge[1],max=rnge[2]),ncol=2)
}
grf_f <- function(x,m,wl){
  sum(apply(m,1,function(mi){
    sin(sqrt(sum((x-mi)^2))/wl)
  }))
}


nwaves <- 30
rnge <- c(-100,100)
dim <- 2
wl <- 2

m <- grf(nwaves,rnge,dim)
d <- sapply(1:1000,function(i){
  k <- runif(dim,min=rnge[1],max=rnge[2])
  grf_f(k,m,wl)
})

shapiro.test(d)
```

Next question, what is the power spectrum?

```{r}
# Example data
set.seed(123)
N <- 200  # Number of data points
M <- 22   # Number of dimensions

# Generate random locations in 22-dimensional space
k <- matrix(runif(N * M, min = 0, max = 1), ncol = M)

# Generate random field values
f <- rnorm(N)

# Define a function to compute the DFT for isotropic fields
compute_isotropic_dft <- function(k, f, num_bins = 50) {
  N <- nrow(k)
  M <- ncol(k)
  
  # Compute the magnitudes of the wave vectors
  k_magnitudes <- sqrt(rowSums(k^2))
  
  # Define the maximum frequency based on the data
  k_max <- max(k_magnitudes)
  
  # Create radial bins
  bins <- seq(0, k_max, length.out = num_bins + 1)
  bin_indices <- cut(k_magnitudes, bins, labels = FALSE, include.lowest = TRUE)
  
  # Initialize arrays to store the DFT results and counts
  power_spectrum <- numeric(num_bins)
  bin_counts <- numeric(num_bins)
  
  # Compute the DFT for each point
  for (i in 1:N) {
    for (j in i:N) {
      freq_magnitude <- sqrt(sum((k[i, ] - k[j, ])^2))
      bin <- cut(freq_magnitude, bins, labels = FALSE, include.lowest = TRUE)
      if (!is.na(bin)) {
        dft_value <- f[i] * f[j] * exp(-2i * pi * freq_magnitude)
        power_spectrum[bin] <- power_spectrum[bin] + Mod(dft_value)^2
        bin_counts[bin] <- bin_counts[bin] + 1
      }
    }
  }
  
  # Normalize by bin counts to get the average power
  power_spectrum <- power_spectrum / bin_counts
  
  return(data.frame(frequency = (bins[-1] + bins[-(num_bins + 1)]) / 2, power = power_spectrum,counts=bin_counts))
}

# Compute the isotropic DFT and power spectrum
result <- compute_isotropic_dft(k, f)

# Extract frequencies and power spectrum
frequencies <- result$frequency
power_spectrum <- result$power

# Plot the power spectrum
plot(frequencies, power_spectrum, type = "b", xlab = "Frequency", ylab = "Power", main = "Isotropic Power Spectrum")

```
```{r}

grf <- function(nwaves,rnge,dim){
  matrix(runif(dim*nwaves,min = rnge[1],max=rnge[2]),ncol=dim)
}
grf_f <- function(x,m,wl){
  sum(apply(m,1,function(mi){
    sin(sqrt(sum((x-mi)^2))/wl)
  }))
}

compute_isotropic_dft <- function(k, f) {
  
  do.call(rbind,lapply(1:nrow(k),function(i){
    do.call(rbind,lapply(1:nrow(k),function(j){
      freq_magnitude <- sqrt(sum((k[i, ] - k[j, ])^2))
      dft_value <- f[i] * f[j] * exp(-2i * pi * freq_magnitude)
      dft_value <- Mod(dft_value)^2
      data.frame(freq_magnitude,dft_value)
    }))
  }))
}

wrap_dft <- function(wl,nreps=30){
  nwaves <- 10
  rnge <- c(-100,100)
  dim <- 22
  
  x <- do.call(rbind,lapply(1:nreps,function(i){
    m <- grf(nwaves,rnge,dim)
    k <- matrix(sample(c(-2,1,0,1,2)+3,dim*30,prob = c(0.01,0.1,2,0.1,0.01),replace=T),ncol=dim)
    f <- apply(k,1,grf_f,m=m,wl=wl)
    dft <- compute_isotropic_dft(k,f)
  }))
  x$dft_value <- x$dft_value/nrow(x)
  dfi <- aggregate(list(power=x$dft_value),by=list(freq=x$freq_magnitude),mean)
  dfi$se <- aggregate(list(se=x$dft_value),by=list(freq=x$freq_magnitude),
                      function(x) sd(x)/sqrt(length(x)))$se
  dfi$wl <- wl
  #dfi$se <- dfi$se/sum(dfi$power)
  #dfi$power <- dfi$power/sum(dfi$power)
  return(dfi)
}







wl <- c(0.2,0.4,0.8,1.6)

df <- do.call(rbind,lapply(wl,wrap_dft))

p <- ggplot(df,aes(x=freq,y=power))+
  facet_grid(rows=vars(wl))+
  geom_point()+
  geom_errorbar(aes(ymin=power-se,ymax=power+se))
p



```